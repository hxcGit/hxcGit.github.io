[{"categories":["daily"],"content":"文章描述","date":"2022-03-20","objectID":"/daily/","tags":["计划","plan","日程"],"title":"每日规划","uri":"/daily/"},{"categories":["daily"],"content":"2022 年 3 月 16 日 周三 阅读材料 https://mp.weixin.qq.com/s/vTZXjq71MZPv9VGoOY6jPg https://segmentfault.com/a/1190000040263156 https://www.cnblogs.com/jo3yzhu/p/13559761.html 学习 https://jimmysong.io/kubernetes-handbook/concepts/crd.html 【暂缓】 CRD 定义【暂缓】 KubeBuilder 大概介绍【暂缓】 ","date":"2022-03-20","objectID":"/daily/:1:0","tags":["计划","plan","日程"],"title":"每日规划","uri":"/daily/"},{"categories":["daily"],"content":"2022 年 3 月 15 日 周二 阅读材料 https://mp.weixin.qq.com/s/_7ofuy2Wp__3B9esO_2oag https://mp.weixin.qq.com/s/rbPMG4NF1g-xsfJeK0YY5A https://mp.weixin.qq.com/s/M0vJFnXaCawdmVsU8sJf7g 学习 Go: channel：https://golang.iswbm.com/c04/c04_04.html option 编程模式：https://mp.weixin.qq.com/s/_7ofuy2Wp__3B9esO_2oag Raven: 阅读相关源码，进一步梳理大纲 进度: 第二天 ","date":"2022-03-20","objectID":"/daily/:2:0","tags":["计划","plan","日程"],"title":"每日规划","uri":"/daily/"},{"categories":["daily"],"content":"2022 年 3 月 14 日 周一 阅读材料 https://mp.weixin.qq.com/s/d6ur5HEUG3qeXAtFM6eE9A https://mp.weixin.qq.com/s/NjRI7gj8wBZExieWZFdYxw https://mp.weixin.qq.com/s/7uBRYNUAnfqjivKqpQFgRA https://mp.weixin.qq.com/s/yqPOlkjoDZLgfsO1XkaQvg https://mp.weixin.qq.com/s/P7B_H-0Qy7EEoaXTllULbQ 调研内容 华为技术挑战大赛 - 流量调度相关内容【初步了解了题目】 学习 阅读 submariner 相关源码 【已转向看 Raven，有了一丁丁点进展】 进度 ： 第一天 ","date":"2022-03-20","objectID":"/daily/:3:0","tags":["计划","plan","日程"],"title":"每日规划","uri":"/daily/"},{"categories":["基础"],"content":"文章描述","date":"2022-03-22","objectID":"/paxos/","tags":["分布式","paxos","共识"],"title":"Paxos","uri":"/paxos/"},{"categories":["基础"],"content":"Paxos 资料链接 https://zhuanlan.zhihu.com/p/31780743 https://www.cnblogs.com/linbingdong/p/6253479.html https://blog.openacid.com/algo/paxos/ chrome-extension://cdonnmffkdaoajfknoeeecmchibpmkmg/assets/pdf/web/viewer.html?file=https%3A%2F%2Fongardie.net%2Fstatic%2Fraft%2Fuserstudy%2Fpaxos.pdf ","date":"2022-03-22","objectID":"/paxos/:1:0","tags":["分布式","paxos","共识"],"title":"Paxos","uri":"/paxos/"},{"categories":["基础"],"content":"一、 背景问题 维基百科 Paxos 是莱斯利·兰伯特（Leslie Lamport），1990 年提出的一种基于消息传递且具有高度容错特性的共识算法 Paxos 常被误称为一致性（consistency）算法，但是 consistency 和 consensus 并不是一个概念。Paxos 是一个共识算法 问题背景 在分布式系统中，会发生各种异常错误情况，如何在一个分布式系统中，快速正确地对某个数据达成共识？Paxos 算法运行在系统中出现宕机故障，可以容忍消息的丢失、延迟、乱序以及重复，但是不考虑 Assume a collection of processes that can propose values. A consensus algorithm ensures that a single one among the proposed values is chosen. If no value is proposed, then no value should be chosen. ","date":"2022-03-22","objectID":"/paxos/:1:1","tags":["分布式","paxos","共识"],"title":"Paxos","uri":"/paxos/"},{"categories":["基础"],"content":"二、 角色 Proposer ： 提出提案（Proposal）。Proposal 信息包括提案编号（Proposal ID）和提议的值（Value） Acceptor ：参与决策，回应 Proposers 的提案。收到提案后可以接受提案，若提案获得大多数接受，则称该提案被批准 Learner ： 不参与决策，从 Proposers/Acceptors 学习达成一致的提案 ","date":"2022-03-22","objectID":"/paxos/:1:2","tags":["分布式","paxos","共识"],"title":"Paxos","uri":"/paxos/"},{"categories":["基础"],"content":"三、 算法流程 Phase 1. ​ (a) A proposer selects a proposal number n and sends a prepare request with number n to a majority of acceptors ​ (b) If an acceptor receives a prepare request with number n greater than that of any prepare request to which it has already responded, then it responds to the request with a promise not to accept any more proposals numbered less than n and with the highest-numbered proposal (if any) that it has accepted. Prepare阶段生成的 number ID 可使用时间戳 ➕Server ID Acceptor进行Promise的承诺 （1）两个 Promise Acceptor 不接受 Proposal ID 小于等于当前请求的Prepare请求 Acceptor 不接受 Proposal ID 小于当前请求的Propose请求 注意上面区别 （2）一个 Accept 回复已经接受过的提案中 Proposal ID 最大的那个提案的 Value（这个 Value 会被 Proposer 接收到后并学习） Phase 2. ​ (a) If the proposer receives a response to its prepare requests (numbered n) from a majority of acceptors, then it sends an accept request to each of those acceptors for a proposal numbered n with a value v, where v is the value of the highest-numbered proposal among the reponses, or is any value if the responses reported no proposals. ​ (b) If an acceptor receives an accept request for a proposal numbered n, it accepts the proposal unless it has already responded to a prepare request having a number greater than n. ","date":"2022-03-22","objectID":"/paxos/:1:3","tags":["分布式","paxos","共识"],"title":"Paxos","uri":"/paxos/"},{"categories":["基础"],"content":"四、 Safety Only a value that has been proposed may be chosen Only a single value is chosen, and a process never learns that a value has been chosen unless it actually has been Requirement P1. An acceptor must accept the first proposal that it receives. （acceptor 必须接受它收到的第一个 proposal） But this requirement raises a problem. Several values could be proposed by different proposers at about the same time, leading to a situation in which every acceptor has accepted a value, but no single value is accepted by a majority of them. Even with just two proposed values, if each is accepted by about half the acceptors, failure of a single acceptor could make it impossibleto learn which of the values was chosen. P1a. An acceptor can accept a proposal numbered n iff it has not responded to a prepare request having a number greater than n P2. If a proposal with value v is chosen, then every higher-numbered proposal that is chosen has value v.（如果值为 v 的 proposal 被选定，则任何被选定的具有更高编号的 proposal 值也一定是 v） Chosen ： A value is chosen when a single proposal with that value has been accepted by a majority of the acceptors. Since numbers are totally ordered, condition P2 guarantees the crucial safetyproperty that only a single value is chosen. (保证只有一个值被选中) P2a. If a proposal with value v is chosen, then every higher-numbered proposal accepted by any acceptor has value v. （如果值为 v 的 proposal 被选定，则对所有的 acceptor，他们接受的任何具有更高编号的 proposal 的值也一定是 v） P2b. If a proposal with value v is chosen, then every higher-numbered proposal issued by any proposer has value v. （如果值为 v 的 proposal 被选定，则对所有的 proposer，他们提出的任何具有更高编号的 proposal 值也一定为 v） P2c. For any v and n, if a proposal with value v and number n is issued, then there is a set S consisting of a majority of acceptors such that either (a) no acceptor in S has accepted any proposal numbered less than n, or (b) v is the value of the highest-numbered proposal among all proposals numbered less than n accepted by the acceptors in S ","date":"2022-03-22","objectID":"/paxos/:1:4","tags":["分布式","paxos","共识"],"title":"Paxos","uri":"/paxos/"},{"categories":["基础"],"content":"五、 活锁 Liveness 多个 proposer 同时运行时，各个 proposal 的编号交替增加，没有任何的 proposal 可以被成功接受 解决 随机延迟，停等（有点类似于 CSMA 解决冲突的思路） 通过选主，只有主 Proposer 才能提出提案 ","date":"2022-03-22","objectID":"/paxos/:1:5","tags":["分布式","paxos","共识"],"title":"Paxos","uri":"/paxos/"},{"categories":["基础"],"content":"拓展资料 ","date":"2022-03-22","objectID":"/paxos/:2:0","tags":["分布式","paxos","共识"],"title":"Paxos","uri":"/paxos/"},{"categories":["基础"],"content":"B 站视频 1. CAP Theorem 一致性 consistency 可用性 availability 分区容错性 partition tolerance 2. 一致性模型 弱一致性 最终一致性 ： 立马读取可能结果不对 DNS（Domain Name System） Gossip（Cassandra 的通信协议） 强一致性 Paxos Raft（multi-paxos） ZAB（multi-paxos） 分布式系统对 fault tolorence 的一般解决方案是 state machine replication 讨论的主题也就是 state machine replication 的共识（consensus）算法 ","date":"2022-03-22","objectID":"/paxos/:2:1","tags":["分布式","paxos","共识"],"title":"Paxos","uri":"/paxos/"},{"categories":["基础"],"content":"OpenACID Blog 学习 1. 核心思想 在廉价的易损设备上，通过多副本的冗余策略实现可靠性 注意此处与 Paxos 的区别，此处在数据库感觉更多的是为了让修改记录落盘，实现一致性，而不是在多个值中选一个进行共识 给出了一个数据。 多副本的数据丢失风险 1 副本 ～ 0.63% 2 副本 ～ 0.00395% 3 副本 ～ 0.000001% n 副本 ～ x^n （x=单副本损坏率） 2. 常见方案 一、 主从异步复制（Mysql 的 binlog 复制） 思路：应该只有主能够写，主收到写请求后，写入本地磁盘，然后返回响应，再同步给其他从节点 问题：在返回响应与同步至从节点之间存在异步，如果此时断电或者主损坏，则数据丢失 二、主从同步复制 思路：应该只有主能够写，主收到写请求后，写入本地磁盘，然后同步给其他从节点，再返回响应 问题：主返回响应之前需要确保同步到所有的从节点，这样效率很低，速度很慢，同时如果有从节点出现问题，则整个完成就完全阻塞 三、 主从半同步复制 思路：应该只有主能够写，主收到写请求后，写入本地磁盘，然后同步给一些从节点（不是全部），再返回响应 问题：如果数据 a 复制给从 1 节点，数据 b 复制给从 2 节点，结果 master 宕机，则从 slave1 和 slave2 恢复出的数据是不一样的，就是说半同步复制还是会存在数据不一致问题 四、多数派写（读） 思路：每条数据必须写入到半数以上机器上，每次读取数据都必须检查半数以上机器是否存在该条数据 问题 1：node1 和 node2 都写入了 a=x，下一次更新时 node2 和 node3 写入了 a=y，这时如果客户读取 node1 和 node2 会发现不一致， 解决 1：通过比较记录时间戳，来选择最新的状态，保证不产生歧义 问题 2：如果客户在写入 a=y 时，只写了 node3 的，node2 还没写进去就挂了，此时个节点中最新的状态 node1-x；node2-x；node3-y，则如果客户读取 node1 和 node2 会得到 x；读取 node2 和 node3 或者 node1 和 node3 会得到 y；因为 node3 中 y 的时间戳是最新的 五、 Paxos 上图存在的问题： 在 x 设置 i 值的同时，这个过程还没做完，y 就准备插一手来设置 i 值了。 个人认为：核心问题发生在没有加锁 文章原话是说：“在 X 或 Y 写之前先做一次多数派读，以便确认是否有其他客户端进程已经在写了，如果有，则放弃” 解读 个人觉得这里的先做一次多数派读就是 Prepare 的过程 Paxos 也并不是发现有人在写就放弃的，而是在 Prepare 的时候就把自己的锁给加上了，然后抢占，所以才会导致活性的问题 这里如果单纯只是分布式加锁，也会存在一个问题，就是双方都只是加了锁，也都是简单的锁，因为请求可以同步过来，那么解决这个问题就是使用时间戳，只有最后一个锁，才是有效的 尚待完善… ","date":"2022-03-22","objectID":"/paxos/:2:2","tags":["分布式","paxos","共识"],"title":"Paxos","uri":"/paxos/"},{"categories":["专业基础"],"content":"网络基础学习整理","date":"2022-03-20","objectID":"/%E7%BD%91%E7%BB%9C/","tags":["网络","network","基础知识"],"title":"网络基础知识","uri":"/%E7%BD%91%E7%BB%9C/"},{"categories":["专业基础"],"content":"网络 ","date":"2022-03-20","objectID":"/%E7%BD%91%E7%BB%9C/:0:0","tags":["网络","network","基础知识"],"title":"网络基础知识","uri":"/%E7%BD%91%E7%BB%9C/"},{"categories":["专业基础"],"content":"一、CIDR CIDR（Classless Inter-Domain Routing，无类域间路由选择）它消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址空间。它可以将好几个 IP 网络结合在一起，使用一种无类别的域际路由选择算法，使它们合并成一条路由从而较少路由表中的路由条目减轻 Internet 路由器的负担。 CIDR 记法 CIDR 还使用“斜线记法”，它又称为 CIDR 记法，即在 IP 地址后面加上一个斜线“/”，然后写上网络前缀所占的比特数（这个数值对应于三级编址中子网掩码中比特 1 的个数）。 IP 地址::={\u003c网络前缀*\u003e,\u003c*主机号\u003e} ","date":"2022-03-20","objectID":"/%E7%BD%91%E7%BB%9C/:1:0","tags":["网络","network","基础知识"],"title":"网络基础知识","uri":"/%E7%BD%91%E7%BB%9C/"},{"categories":["专业基础"],"content":"二、 IPSec （Internet Protocol Security） 学习链接 https://support.huawei.com/enterprise/zh/doc/EDOC1100008291/370abd69 https://support.huawei.com/enterprise/zh/doc/EDOC1100041456/f2298f86 https://cshihong.github.io/2019/04/09/IPSec-VPN%E4%B9%8BIKEv2%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/ ike2 2.1 概述 是一系列网络协议的集合 AH（Authentication Header） 验证头 报文头验证协议，提供数据校验功能。 ESP（Encapsulating Security Payload）封装安全载荷 提供数据加密功能 比较 AH 和 ESP 都能提供验证功能，主要采用算法 MD5、SHA1、SHA2-256**（建议）**、SHA2-384、SHA2-512 ESP 可以提供加密功能 DES、3DES、AES**（建议）** 2.2 IKE（Internet Key Exchange）因特网密钥交换 可以动态协商密钥 IKE 建立在 ISAKMP 框架之上，采用 DH（Diffie-Hellman）算法，可以提升密钥的安全性，并降低 IPSec 管理复杂度 2.3 IPSec 原理介绍 ipsec 在对等体之间建立安全联盟 SA（security association） SA 由三元组标识 SPI（security parameter index）安全参数索引： 32 位的唯一标识 SA 的数值 目的 IP 地址 使用的安全协议（AH 或 ESP） SA 是单向逻辑，为了建立双向连接，需要有两个安全联盟 另外，SA 的个数还与安全协议相关。如果只使用 AH 或 ESP 来保护两个对等体之间的流量，则对等体之间就有两个 SA，每个方向上一个。如果对等体同时使用了 AH 和 ESP，那么对等体之间就需要四个 SA，每个方向上两个，分别对应 AH 和 ESP。 封装模式 传输模式 隧道模式： IKE 与 IPSec 关系 对等体之间建立一个 IKE SA 完成身份验证和密钥信息交换后，在 IKE SA 的保护下，根据配置的 AH/ESP 安全协议等参数协商出一对 IPSec SA。此后，对等体间的数据将在 IPSec 隧道中加密传输 ","date":"2022-03-20","objectID":"/%E7%BD%91%E7%BB%9C/:1:1","tags":["网络","network","基础知识"],"title":"网络基础知识","uri":"/%E7%BD%91%E7%BB%9C/"},{"categories":["工具"],"content":"npm 包管理工具的使用学习","date":"2022-03-20","objectID":"/npm/","tags":["npm","包管理","实用工具"],"title":"Npm 使用","uri":"/npm/"},{"categories":["工具"],"content":"一、 npm install 参数 1.1 npm install 安装单个 packageName 包 无参数 默认情况 npm install packageName 默认情况下，不加参数。会安装包，并将依赖包的名称添加 package.json 中的 dependencies 字段。 –save 参数 npm install --save packageName 添加--save参数，与默认情况效果相同。会安装包，并将依赖包的名称添加到 package.json 中的 dependencies 字段。 –save-dev 参数 npm install --save-dev packageName 添加--save-dev参数，会安装包，并将依赖包的名称添加到 package.json 中的 devDependencies 字段。 安装某个包时，这个包中 package.json 的 dependencies 字段中的依赖会被自动安装，而 devDependencies 字段中的依赖不会被安装。 1.2 npm install 初始化项目 无参数 直接初始化 npm install 我们常用 npm install 初始化项目，安装项目所需的依赖。但更深入的细节是：直接使用 npm install 时，项目 package.json 中 dependencies 字段和 devDependencies 字段中的依赖包都会被安装。 –production 参数 npm install --production 添加--production安装项目所需的依赖时，只有 dependencies 字段中的依赖包会被安装，devDependencies 中的依赖包不会被安装。 –only=dev 参数 npm install --only=dev 添加--only=dev安装项目所需依赖时，只有 devDependencies 字段中的依赖包会被安装，dependencies 字段中的依赖包不会被安装。与添加–production 的效果刚好相反。 还有一个参数：–dev，它的效果与–only=dev 相同，但已经被废弃，请使用–only=dev 代替。 ","date":"2022-03-20","objectID":"/npm/:0:1","tags":["npm","包管理","实用工具"],"title":"Npm 使用","uri":"/npm/"},{"categories":["工具"],"content":"markdown写作学习","date":"2022-03-20","objectID":"/markdown/","tags":["markdown","写作","实用工具"],"title":"Markdown","uri":"/markdown/"},{"categories":["工具"],"content":"一、锚点-业内跳转 需要链接的地方 \u003cspan id = \"xxx\"\u003e 内容 \u003c/span\u003e 链接按钮 [链接标题](#xxx) ","date":"2022-03-20","objectID":"/markdown/:0:0","tags":["markdown","写作","实用工具"],"title":"Markdown","uri":"/markdown/"},{"categories":["工具"],"content":"文章描述","date":"2022-03-20","objectID":"/ssh/","tags":["运维","SSH","远程连接","实用工具"],"title":"SSH配置","uri":"/ssh/"},{"categories":["工具"],"content":"一、 远程用户：免密登陆+IP 重命名 用户目录下的.ssh目录内，添加配置文件config Host 47.103.81.142 HostName cloudHost User root ServerAliveInterval 20 C:\\Windows\\System32\\drivers\\etc\\hosts需要添加内容 47.103.81.142 cloudHost cat ~/.ssh/id_rsa.pub \u003e\u003e ~/.ssh/authorized_keys ","date":"2022-03-20","objectID":"/ssh/:0:1","tags":["运维","SSH","远程连接","实用工具"],"title":"SSH配置","uri":"/ssh/"},{"categories":["工具"],"content":"二、 连接不中断 修改配置文件~/.ssh/config 添加配置项ServerAliveInterval=30 ","date":"2022-03-20","objectID":"/ssh/:0:2","tags":["运维","SSH","远程连接","实用工具"],"title":"SSH配置","uri":"/ssh/"},{"categories":["理财"],"content":"投资理财的简要理解","date":"2022-03-20","objectID":"/%E7%90%86%E8%B4%A2%E6%A6%82%E8%BF%B0/","tags":["投资","理财"],"title":"投资概述","uri":"/%E7%90%86%E8%B4%A2%E6%A6%82%E8%BF%B0/"},{"categories":["理财"],"content":"🔗 https://www.zhihu.com/question/24435403/answer/276767603?utm_source=wechat_session\u0026utm_medium=social\u0026utm_oi=924545603512471552\u0026utm_content=group1_Answer\u0026utm_campaign=shareopn ","date":"2022-03-20","objectID":"/%E7%90%86%E8%B4%A2%E6%A6%82%E8%BF%B0/:0:0","tags":["投资","理财"],"title":"投资概述","uri":"/%E7%90%86%E8%B4%A2%E6%A6%82%E8%BF%B0/"},{"categories":["理财"],"content":"一、 钱的几种投资方式 1. 现金类资产 如：现金、银行存款、货币基金（这个和买的基金是一个东西？） 平均收益 3%-4%，几乎没有亏损。 一般银行整存整取一年，也就 1.7%左右，即整存10w，一年获利1750 按照 3%计算，10w 一年获利 3000 2. 固定收益类资产 如：国债、金融债、企业债、央行票据和债券型基金等 平均收益 5%-7%，亏损概率低，也不是不会亏损 按 5%计算，整存10w，一年获利5000 3. 权益类资产 如：股票、混合型基金、权证等 平均收益 10%-20%，但是遇到非常不好的行情，亏 50%也是有可能 ","date":"2022-03-20","objectID":"/%E7%90%86%E8%B4%A2%E6%A6%82%E8%BF%B0/:0:1","tags":["投资","理财"],"title":"投资概述","uri":"/%E7%90%86%E8%B4%A2%E6%A6%82%E8%BF%B0/"},{"categories":["理财"],"content":"二、理财要建立不同的“账户”，专款专用 （1） 明确需求 长期-低波动-低收益【打死不能动的钱】： 养老、买房（还款） 长期-中等波动-中等收益： 买车、生娃养娃、父母赡养、结婚 短期-高波动-高收益【小小投资，亏了不会哭的钱】：刨除长期需求后多出的钱 占比目前现金流的 5%，不要超过 10% （2） 建立“账户” 针对上述不同的需求，基于收入来源不同的分配比例划分到对应的需求，专款专用 按照月度/年度规划制定 excel 表格 这张表大概来说粉色部分就是预计算的资金缺口 如果粉丝部分不能填补，两种思路，增加风险投资、降低预期获利值 ","date":"2022-03-20","objectID":"/%E7%90%86%E8%B4%A2%E6%A6%82%E8%BF%B0/:0:2","tags":["投资","理财"],"title":"投资概述","uri":"/%E7%90%86%E8%B4%A2%E6%A6%82%E8%BF%B0/"},{"categories":["理财"],"content":"三、 指数基金（是不是常说的基金？） 指数基金是比较被推荐的 （1） 投资步骤 1）挑选处于低估值的指数 2）确定投资的金额 3）确定投资的频率 4）坚持不懈地定期不定额投入基金 5）高估值时卖出换仓其他低估值的基金 （2）如果估值 每股盈利/每股价格-10 年期国债收益率，值高则是低位，值低则是高位（多少是高点，多少是低点，如果评估，可能需要借鉴股票？） 市盈率： 一般市盈率 15 以下低估，15-20 持有，30 以上高估 钢铁，石化，纺织这种强周期的行业，市盈率不该太高 食品，消费，制药的抗周期性比较强，一般市盈率 20-30 倍是正常估值 还要结合历史低位分数线看，一般历史低位 10%分数线就是非常难得的定投机会了（什么是历史低位分数线？） 所以你可以参考**“且慢”或“天天”或“蛋卷”**这些基金平台提供的估值百分位，一般来讲，跌倒估值百分位 50%以下就可以进场了 ","date":"2022-03-20","objectID":"/%E7%90%86%E8%B4%A2%E6%A6%82%E8%BF%B0/:0:3","tags":["投资","理财"],"title":"投资概述","uri":"/%E7%90%86%E8%B4%A2%E6%A6%82%E8%BF%B0/"},{"categories":["native cloud"],"content":"Kubernetes 基础 ","date":"2022-03-19","objectID":"/kubernetes%E5%9F%BA%E7%A1%80/:0:0","tags":[],"title":"Kubernetes基础","uri":"/kubernetes%E5%9F%BA%E7%A1%80/"},{"categories":["native cloud"],"content":"一、架构 ","date":"2022-03-19","objectID":"/kubernetes%E5%9F%BA%E7%A1%80/:1:0","tags":[],"title":"Kubernetes基础","uri":"/kubernetes%E5%9F%BA%E7%A1%80/"},{"categories":["native cloud"],"content":"1.1 组件 Master ： scheduler、API-Server、rc（副本控制器） Etcd ： 存储（键值对）（分布式）（持久化） v2:内存 v3: DB Node ： kubelet（与容器运行时进行交互）、kube proxy（负载均衡，写入规则至 iptables） CoreDNS ： 为集群中 svc 创建“域名-IP”的对应解析 Ingress Controller ： 实现七层的代理 ","date":"2022-03-19","objectID":"/kubernetes%E5%9F%BA%E7%A1%80/:1:1","tags":[],"title":"Kubernetes基础","uri":"/kubernetes%E5%9F%BA%E7%A1%80/"},{"categories":["native cloud"],"content":"二、Pod 状态与生命周期管理 ","date":"2022-03-19","objectID":"/kubernetes%E5%9F%BA%E7%A1%80/:2:0","tags":[],"title":"Kubernetes基础","uri":"/kubernetes%E5%9F%BA%E7%A1%80/"},{"categories":["native cloud"],"content":"2.3 Init 容器 (1) 探针 init C 可以做服务探针，但是 init C 执行完之后就无法持续在线了 探针是由 kubelet 对容器执行的定期诊断，要执行的话，kubelet 需要调用容器实现的 handler execAction ：在容器中执行指定命令，成功则诊断成功 TCPSocketAction：对容器对应 IP 的 tcp 端口进行检查，如果端口打开，则诊断成功 HTTPGetAction：执行七层 HTTP 请求，状态码满足要求则诊断成功 两种探测方案 livenessProbe : 存活探测 livenessProbe-exec ：执行命令 readinessProbe ：就绪探测 readinessProbe-httpget ： http 请求 ","date":"2022-03-19","objectID":"/kubernetes%E5%9F%BA%E7%A1%80/:2:1","tags":[],"title":"Kubernetes基础","uri":"/kubernetes%E5%9F%BA%E7%A1%80/"},{"categories":["native cloud"],"content":"三、集群资源管理 资源清单类别 名称空间级别 工作负载型：Pod、RS、Deployment、Statefulset、DeamonSet、Job… 服务发现及负载均衡： Service、Ingress 集群级别（全局可见资源） namespace、node、role、clusterRole 元数据型资源 HPA ","date":"2022-03-19","objectID":"/kubernetes%E5%9F%BA%E7%A1%80/:3:0","tags":[],"title":"Kubernetes基础","uri":"/kubernetes%E5%9F%BA%E7%A1%80/"},{"categories":["native cloud"],"content":"3.1 Node (1) 信息 (2) Lease 内容——节点心跳 Kubernetes 节点发送的心跳帮助你的集群确定每个节点的可用性，并在检测到故障时采取行动。 对于节点，有两种形式的心跳: 更新节点的 .status Lease 对象 在 kube-node-lease 命名空间中。 每个节点都有一个关联的 Lease 对象。 与 Node 的 .status 更新相比，Lease 是一种轻量级资源。 使用 Leases 心跳在大型集群中可以减少这些更新对性能的影响。 kubelet 负责创建和更新节点的 .status，以及更新它们对应的 Lease。 当状态发生变化时，或者在配置的时间间隔内没有更新事件时，kubelet 会更新 .status。 .status 更新的默认间隔为 5 分钟（比不可达节点的 40 秒默认超时时间长很多）。 kubelet 会每 10 秒（默认更新间隔时间）创建并更新其 Lease 对象。 Lease 更新独立于 NodeStatus 更新而发生。 如果 Lease 的更新操作失败，kubelet 会采用指数回退机制，从 200 毫秒开始 重试，最长重试间隔为 7 秒钟。 lease 资源全称 leases.coordination.k8s.io # 获取lease资源 kubectl get leases.coordination.k8s.io --all-namespaces (3) Condition conditions 字段描述所有 Running 节点的状态。 节点状况 描述 Ready 如节点是健康的并已经准备好接收 Pod 则为 True；False 表示节点不健康而且不能接收 Pod；Unknown 表示节点控制器在最近 node-monitor-grace-period 期间（默认 40 秒）没有收到节点的消息 DiskPressure True 表示节点存在磁盘空间压力，即磁盘可用量低, 否则为 False MemoryPressure True 表示节点存在内存压力，即节点内存可用量低，否则为 False PIDPressure True 表示节点存在进程压力，即节点上进程过多；否则为 False NetworkUnavailable True 表示节点网络配置不正确；否则为 False (4) PodCIDR PodCIDR 与 PodCIDRs 区别？ (5) ProviderID 当节点是公有云厂商提供的云主机时，这个属性表示公有云系统中对云主机的唯一标识，格式为：\u003cProviderName\u003e://\u003cProviderSpecificNodeID\u003e (6) Node 管理 一、node 调度之禁止调度（平滑维护）-cordon、drain、delete cordon、drain 和 delete 三个命令都会使 node 停止被调度，后期创建的 pod 不会继续被调度到该节点上，但操作的暴力程度却不一样。 1. cordon 停止调度（之后不可调度，临时从 K8S 集群隔离） 影响最小，只会将 node 标识为 SchedulingDisabled 不可调度状态。 之后 K8S 再创建的 pod 资源，不会被调度到该节点。 旧有的 pod 不会受到影响，仍正常对外提供服务。 禁止调度命令\"kubectl cordon node_name\"。 恢复调度命令\"kubectl uncordon node_name\"。（恢复到 K8S 集群中，变回可调度状态） 2. drain 驱逐节点（先不可调度，然后排干） 首先，驱逐 Node 上的 pod 资源到其他节点重新创建。 接着，将节点调为 SchedulingDisabled 不可调度状态。 禁止调度命令\"kubectl drain node_name –force –ignore-daemonsets –delete-local-data\" 恢复调度命令\"kubectl uncordon node_name\"。（恢复到 K8S 集群中，变回可调度状态） drain 方式是安全驱逐 pod，会等到 pod 容器应用程序优雅停止后再删除该 pod。 drain 驱逐流程：先在 Node 节点删除 pod，然后再在其他 Node 节点创建该 pod。所以为了确保 drain 驱逐 pod 过程中不中断服务（即做到\"无感知\"地平滑驱逐），必须保证要驱逐的 pod 副本数大于 1，并且采用了“反亲和策略”将这些 pod 调度到不同的 Node 节点上了！也就是说，在\"多个 pod 副本+反亲和策略\"的场景下，drain 驱逐过程对容器服务是没有影响的。 需要注意： 对节点执行维护操作之前（例如：内核升级，硬件维护等），您可以使用 kubectl drain 安全驱逐节点上面所有的 pod。 drain 安全驱逐方式将会允许 pod 里面的容器遵循指定的 PodDisruptionBudgets 执行优雅中止。也就是说，drain 安全驱逐可以做到：优雅地终止 pod 里的容器进程。 kubectl drain 返回成功表明所有的 pod （除了排除的那些）已经被安全驱逐（遵循期望优雅的中止期，并且没有违反任何应用程序级别的中断预算）。 然后，通过对物理机断电或者在云平台上删除节点所在的虚拟机，都能安全的将节点移除。 如下尚未学习 一般线上 K8S 的 PDB（PodDisruptionBudgets）配置的也是符合 Pod 驱逐的理想情况的，即 maxUnavailable 设置为 0，maxSurge 设置为 1： replicas:3strategy:rollingUpdate:maxSurge:1maxUnavailable:0type:RollingUpdate 默认情况下，kubectl drain 会忽略那些不能杀死的系统类型的 pod。drain 命令中需要添加三个参数：–force、–ignore-daemonsets、–delete-local-data –force 当一些 pod 不是经 ReplicationController, ReplicaSet, Job, DaemonSet 或者 StatefulSet 管理的时候就需要用–force 来强制执行 (例如:kube-proxy) –ignore-daemonsets 无视 DaemonSet 管理下的 Pod。即–ignore-daemonsets 往往需要指定的,这是因为 deamonset 会忽略 unschedulable 标签(使用 kubectl drain 时会自动给节点打上不可调度标签),因此 deamonset 控制器控制的 pod 被删除后可能马上又在此节点上启动起来,这样就会成为死循环.因此这里忽略 daemonset。 –delete-local-data 如果有 mount local volumn 的 pod，会强制杀掉该 pod。 为什么能优雅的驱逐？和先驱逐再新建的顺序有关还是和 PodDisruptionBudgets 策略有关 3. delete 删除节点 首先，驱逐 Node 节点上的 pod 资源到其他节点重新创建。 驱逐流程：先在 Node 节点删除 pod，然后再在其他 Node 节点上创建这些 pod。 node 节点删除，master 失去对其控制，该节点从 k8s 集群摘除。 delete 是一种暴力删除 node 的方式。在驱逐 pod 时是强制干掉容器进程，做不到优雅终止 Pod。相比较而言，显然 drain 更安全。 恢复调度（即重新加入到 K8S 集群中） delete 删除后，后续如果需重新加入 K8S 集群。则需要重启 node 节点的 kubelet 服务，重启后，基于 node 的自注册功能，该节点才能重新加入到 K8S 集群，并且恢复使用（即恢复可调度的身份）。 另外：如果 kubelet 服务重启后，node 节点系统时间跟其他节点不一致，则导致该节点证书会失效！kubelet 注册后，还需要手动 approve 签发 TLS 认证操作了。如下示例： 二、 node 添加（向 API server 添加） 1. 节点的 kubelet 向控制面自注册 当 kubelet 标志 --register-node 为 true（默认）时，它会尝试向 API 服务注册自己。 这是首选模式，被绝大多数发行版选用。 2. 手动添加 node 对象 { \"kind\": \"Node\", \"apiVersion\": \"v1\", \"metadata\": { \"name\": \"10.240.79.157\", \"labels\": { \"name\": \"my-first-k8s-node\" } } } 说明： Kubernetes 会一直保存着非法节点对应的对象，并持续检查该节点是否已经 变得健康。 你，或者某个控制器必需显式地删除该 Node 对象以停止健康检查操作。 Node 对象的名称必须是合法的 DNS 子域名。 (7) 节点控制器 节点控制器是 Kubernetes 控制面组件，管理节点的方方面面。 节点控制器在节点的生命周期中扮演多个角色。 第一个是当节点注册时为它分配一个 CIDR 区段（如果启用了 CIDR 分配）。 第二个是保持节点控制器内的节点列表与云服务商所提供的可用机器列表同步。 如果在云环境下运行，只要某节点不健康，节点控制器就会询问云服务是否节点的虚拟机仍可用。 如果不可用，节点控制器会将该节","date":"2022-03-19","objectID":"/kubernetes%E5%9F%BA%E7%A1%80/:3:1","tags":[],"title":"Kubernetes基础","uri":"/kubernetes%E5%9F%BA%E7%A1%80/"},{"categories":["native cloud"],"content":"3.2 Namespaces 在一个 Kubernetes 集群中可以使用 namespace 创建多个 “虚拟集群”，实现集群间资源的隔离 (1) 一些细节点 删除一个 namespace 会自动删除所有属于该 namespace 的资源。 default 和 kube-system 命名空间不可删除；default、kube-system 以及 kube-public 都是默认命名空间 用户的普通应用在 defalut 下面 与集群管理相关的为整个集群提供服务的应用一般部署在 kube-system PersistentVolume 是不属于任何 namespace 的，但 PersistentVolumeClaim 是属于某个特定 namespace 的。 Event 是否属于 namespace 取决于产生 event 的对象。 v1.7 版本增加了 kube-public 命名空间，该命名空间用来存放公共的信息，一般以 ConfigMap 的形式存放。 namespaces 不包括 node 和 persistentVolume，那为啥 dashboard 可以实现 node 隔离呢？ ","date":"2022-03-19","objectID":"/kubernetes%E5%9F%BA%E7%A1%80/:3:2","tags":[],"title":"Kubernetes基础","uri":"/kubernetes%E5%9F%BA%E7%A1%80/"},{"categories":["native cloud"],"content":"3.3 Label Label 是附着到 object 上（例如 Pod）的键值对。 \"labels\": { \"key1\" : \"value1\", \"key2\" : \"value2\" } k8s 将 lables 最终索引和反向索引用来优化查询和 watch，不要在 label 中使用大型、非标识的结构化数据，记录这样的数据应该用 annotation (1) 使用 label 情形 可以尝试如下标签 \"release\" : \"stable\", \"release\" : \"canary\" \"environment\" : \"dev\", \"environment\" : \"qa\", \"environment\" : \"production\" \"tier\" : \"frontend\", \"tier\" : \"backend\", \"tier\" : \"cache\" \"partition\" : \"customerA\", \"partition\" : \"customerB\" \"track\" : \"daily\", \"track\" : \"weekly\" \"team\" : \"teamA\",\"team:\" : \"teamB\" (2) 语法规则 Key 不能超过 63 个字符 可以使用前缀，前缀使用/分隔，前缀需要是 DNS 子域，不得超过 253 个字符，系统中自动化组件创建的 lable 必须指定前缀 起始必须是字母（大小写都可以）或数字，中间可以有连字符、下划线和点 Value 不得超过 63 个字符 起始必须是字母（大小写都可以）或数字，中间可以有连字符、下划线和点 (3) Selector 选择器 label 不是唯一的，多个对象可能有相同的 label 通过 selector 可以选择一个 obj 集合，对这个集合进行整体的操作 1. 方式一： equality-based 基于等值 可以使用操作符=、==、!= = 和 == 是一个意思 可使用逗号分隔多个表达式 2. 方式二：set-based 基于集合 可以使用 in、notion、!操作符 可以直接写出某个 label-key，表示直接选中，而不管对应的 value 是何值 ！表示没有该 label 的那些 obj environment in (production, qa) # env 等于product或者qa tier notin (frontend, backend) # tier 不等于frontend或者backend的资源 partition # 键为partition !partition # 键不为partition的全部 3. 资源中示例使用 selector pod apiVersion:v1kind:Podmetadata:name:cuda-testspec:containers:- name:cuda-testimage:\"k8s.gcr.io/cuda-vector-add:v0.1\"resources:limits:nvidia.com/gpu:1nodeSelector:accelerator:nvidia-tesla-p100 service 和 ReplicationController \"selector\": { \"component\": \"redis\", } selector:component:redis 等价于 component=redis 或者 component in（redis） job、Deployment、Replica Set 和 DemonSet 支持基于集合的需求 selector:matchLabels:component:redismatchExpressions:- {key: tier, operator: In, values:[cache] }- {key: environment, operator: NotIn, values:[dev] } matchLabels 是由 {key,value} 对组成的映射 有效的运算符包括 In、NotIn、Exists 和 DoesNotExist 来自 matchLabels 和 matchExpressions 的所有要求都按逻辑与的关系组合到一起,它们必须都满足才能匹配 4. 通过标签/selector 将 pod 分配给节点 场景：例如，确保 Pod 最终落在连接了 SSD 的机器上，或者将来自两个不同的服务 且有大量通信的 Pods 放置在同一个可用区。 一个简单的 nginx 配置文件 apiVerions:v1kind:Podmetadata:name:nginx-hxclabels:env:testspec:containers:- name:nginximage:nginximagePullPolicy:IfNotPresentnodeSelector:test/role:houWorker (4) 亲和性与反亲和性 相比于 selector 优点 语言更具表现力，（不局限于只能使用完全匹配且 AND 连接的规则） 可以设置“软需求”，即如果实在无法满足要求，仍然是可调度的 可以使用节点上的 pod 的标签来约束，而不仅仅是节点的标签 一、节点亲和性 requiredDuringSchedulingIgnoredDuringExecution “硬需求” 必须满足 preferredDuringScheduingIgnoredDuringExecution “软需求” 尽量满足 IgnoredDuringExecution 意味着，在 pod 运行时，如果标签不再满足要求也不会被驱逐 节点亲和性 affinity 部署示例 apiVersion:v1kind:Podmetadata:name:with-node-affinityspec:containers:- name:with-node-affinityimage:k8s.gcr.io/pause:2.0imagePullPolicy:IfNotPresentaffinity:nodeAffinity:requiredDuringSchedulingIgnoredDuringExecution:nodeSelectorTerms:- matchExpressions:- key:test.com/roleoperator:Invalues:- hxcWorker- hxcWorker2preferredDuringSchedulingIgnoredDuringExecution:- weight:1preference:matchExpressions:- key:another/roleoperator:Invalues:- anotherWorker 亲和性支持的操作符 In、NotIn、Exists、DoesNotExist、Gt、Lt 反亲和性操作符 NotIn、DoesNotExist 如果同时指定nodeSelector和nodeAffinity，则两者都要满足，才能将 pod 调度到节点上 一个nodeSelectorTerms中的任意一个matchExpressions满足就可以调度 nodeAffinity:requiredDuringSchedulingIgnoredDuringExecution:nodeSelectorTerms:# array- matchExpressions:- key:test.com/roleoperator:Invalues:- hxcWorker- hxcWorker2- key:matchoperator:Invalues:- yep- matchExpressions:- key:match2operator:Invalues:- hxcWorker- hxcWorker2# 两个matchExpressions满足一个即可 一个matchExpression内的全部规则都匹配才能调度 nodeAffinity:requiredDuringSchedulingIgnoredDuringExecution:nodeSelectorTerms:# array- matchExpressions:- key:test.com/roleoperator:Invalues:- hxcWorker- hxcWorker2- key:matchoperator:Invalues:- yep# test.com/role和match两条标签均要满足才能调度 亲和性也是只在节点调度时有效，即如果运行时，标签修改，也不会驱逐节点 preferredDuringSchedulingIgnoredDuringExecution中的weight字段范围时 1-100，最终通过总分与其他节点 pk 二、Pod 间亲和性/反亲和性（约束 pod 标签而不是节点标签） pod 间亲和性需要大量的处理，会影响集群调度的速度，如果集群规模过大，不建议使用 # 示例apiVersion:v1kind:Podmetadata:name:with-pod-affinityspec:affinity:podAffinity:# 关键结构一：podAffinityrequiredDuringSchedulingIgnoredDuringExecution:- labelSelector:matchExpressions:- key:securityoperator:Invalues:- S1topologyKe","date":"2022-03-19","objectID":"/kubernetes%E5%9F%BA%E7%A1%80/:3:3","tags":[],"title":"Kubernetes基础","uri":"/kubernetes%E5%9F%BA%E7%A1%80/"},{"categories":["native cloud"],"content":"四、控制器 ","date":"2022-03-19","objectID":"/kubernetes%E5%9F%BA%E7%A1%80/:4:0","tags":[],"title":"Kubernetes基础","uri":"/kubernetes%E5%9F%BA%E7%A1%80/"},{"categories":["native cloud"],"content":"4.1 Deployment deployment 会去创建对应的 rs，rs 再去创建对应的 pod dp 支持滚动升级和回滚应用（通过控制 rs 的版本） 比如滚动更新会创建新的 rs，但是旧的 rs 不删除，这样就可以实现回滚 dp 支持暂停和继续（通过控制 rs 存在的数量？？？） ","date":"2022-03-19","objectID":"/kubernetes%E5%9F%BA%E7%A1%80/:4:1","tags":[],"title":"Kubernetes基础","uri":"/kubernetes%E5%9F%BA%E7%A1%80/"},{"categories":["native cloud"],"content":"4.2 StateFulSet 有状态服务不太好处理，docker 是通过持久化存储卷的方式来实现，k8s 提供了 statefule 来支持 但是对于 mysql，可能现在的支持还不是特别的完善 通过稳定的持久化存储，pod 重新调度后能够访问到相同的持久化数据，基于 PVC 来实现 稳定的网络标识：PodName 和 HostName 不变，基于 headless service(即没有 cluster ip 的 service)来实现 有序部署，pod 的部署是有前后顺序的，基于 init C 来实现 有序收缩，有序删除 ","date":"2022-03-19","objectID":"/kubernetes%E5%9F%BA%E7%A1%80/:4:2","tags":[],"title":"Kubernetes基础","uri":"/kubernetes%E5%9F%BA%E7%A1%80/"},{"categories":["native cloud"],"content":"4.3 DaemonSet(还不是特别理解) DaemonSet 确保全部（或者一些）Node 上运行一个 Pod 的副本。当有 Node 加入集群时，也会为他们新增一个 Pod 。当有 Node 从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod。 使用 DaemonSet 的一些典型用法： 运行集群存储 daemon，例如在每个 Node 上运行 glusterd、ceph。 在每个 Node 上运行日志收集 daemon，例如fluentd、logstash。 在每个 Node 上运行监控 daemon，例如 Prometheus Node Exporter、collectd、Datadog 代理、New Relic 代理，或 Ganglia gmond。 一个简单的用法是，在所有的 Node 上都存在一个 DaemonSet，将被作为每种类型的 daemon 使用。 一个稍微复杂的用法可能是，对单独的每种类型的 daemon 使用多个 DaemonSet，但具有不同的标志，和/或对不同硬件类型具有不同的内存、CPU 要求。 ","date":"2022-03-19","objectID":"/kubernetes%E5%9F%BA%E7%A1%80/:4:3","tags":[],"title":"Kubernetes基础","uri":"/kubernetes%E5%9F%BA%E7%A1%80/"},{"categories":["native cloud"],"content":"4.4 ReplicationController （已经是过去时了）， ReplicaSet RC 就是最基本，维持 pod 副本数不多也不少 RS 与 RC 没有什么不同，支持集合式的 selector RS 具有扩容、缩容功能 kubectl explain rs ","date":"2022-03-19","objectID":"/kubernetes%E5%9F%BA%E7%A1%80/:4:4","tags":[],"title":"Kubernetes基础","uri":"/kubernetes%E5%9F%BA%E7%A1%80/"},{"categories":["native cloud"],"content":"4.5 Job、 CronJob 处理脚本执行的问题 job 如果运行脚本没有 0 成功退出，会再次重新运行 cronjon 只是在 job 的基础上实现周期性运行（通过在特定的时间循环创建 job 来实现） ","date":"2022-03-19","objectID":"/kubernetes%E5%9F%BA%E7%A1%80/:4:5","tags":[],"title":"Kubernetes基础","uri":"/kubernetes%E5%9F%BA%E7%A1%80/"},{"categories":["native cloud"],"content":"4.6 Horizontal Pod Autoscaling （水平自动扩展） 可以理解为不是一个控制器，而是一个控制器的附属品 创建了一个 dp 之后，可以再创建一个 hpa 来管理控制 dp 可以通过一些资源指标（CPU，mem）等来实现 pod 缩放 ","date":"2022-03-19","objectID":"/kubernetes%E5%9F%BA%E7%A1%80/:4:6","tags":[],"title":"Kubernetes基础","uri":"/kubernetes%E5%9F%BA%E7%A1%80/"},{"categories":["native cloud"],"content":"五、服务发现与路由 ","date":"2022-03-19","objectID":"/kubernetes%E5%9F%BA%E7%A1%80/:5:0","tags":[],"title":"Kubernetes基础","uri":"/kubernetes%E5%9F%BA%E7%A1%80/"},{"categories":["native cloud"],"content":"5.1 service 每个 svc 可以理解为一个微服务 (1) svc 负载均衡 只能实现 4 层负载均衡，没有 7 层负载均衡能力 (2) svc 类型 clusterIP ： 自动分配一个 cluster 内部（节点内部）可以访问的 IP，即节点内其他 pod 可以通过这个 ip 访问到 svc 即访问到 svc 对应的 pod NodePort ： 在 clusterIp 的基础上，分配了一个端口，可以通过 IP：port 方式来访问服务，这种方式就将服务暴露到外部去了，一般端口是会做一个映射的 80-\u003e30001 这种 LoadBalancer ：在 nodeport 的基础上，借助 cloud provider 创建一个外部负载均衡器，将请求转发到 nodeIP：nodeport，相当于 svc 可能会在好几个 node 节点上都创建多个 pod，那么可以在这些 node 之前加一个负载均衡器来实现对于 nodeIP：port 这种方式的 svc 的访问，均衡器可以是自己整的 nginx，这里则是指云服务提供商提供的服务 ExternalName ： 只是为了在集群内部定义一个统一的对外面的某个访问的 svc，因为可能集群内部多个 pod 都会要访问这个外部服务，但是如果外部 IP 变了的话，就要改动很大，而使用 ExternalName 这种 svc 的话，则只用改这个 svc 中的配置 (3) svc 原理 client 访问 svc，转发到对应的 pod 是通过 iptables 来实现的 iptables 规则的生成是通过 kube-proxy（服务发现）来实现的 ","date":"2022-03-19","objectID":"/kubernetes%E5%9F%BA%E7%A1%80/:5:1","tags":[],"title":"Kubernetes基础","uri":"/kubernetes%E5%9F%BA%E7%A1%80/"},{"categories":["native cloud"],"content":"六、 身份与权限控制 ","date":"2022-03-19","objectID":"/kubernetes%E5%9F%BA%E7%A1%80/:6:0","tags":[],"title":"Kubernetes基础","uri":"/kubernetes%E5%9F%BA%E7%A1%80/"},{"categories":["native cloud"],"content":"6.1 kubeconfig kubeconfig 是 kubernetes 集群中各个组件(api-server 客户端)连入 api-server 的时候 , 使用的认证格式的客户端配置文件 查看 kubeconfig 配置文件 kubectl config view kubeconfig 证书 和 token 两种认证方式是 K8S 中最简单通用的两种认证方式 生成 kubeconfig 的配置步骤 1、定义变量 export KUBE_APISERVER=“https://172.20.0.2:6443” 2、设置集群参数 kubectl config set-cluster kubernetes –certificate-authority=/etc/kubernetes/ssl/ca.pem –embed-certs=true –server=${KUBE_APISERVER} #可以指定路径 kubeconfig=/root/config.conf 说明：集群参数主要设置了所需要访问的集群的信息。使用 set-cluster 设置了需要访问的集群，如上为 kubernetes；–certificate-authority 设置了该集群的公钥；–embed-certs 为 true 表示将 –certificate-authority 证书写入到 kubeconfig 中；–server 则表示该集群的 kube-apiserver 地址。 3、设置客户端认证参数 kubectl config set-credentials admin –client-certificate=/etc/kubernetes/ssl/admin.pem –embed-certs=true –client-key=/etc/kubernetes/ssl/admin-key.pem #可以指定路径 kubeconfig=/root/config.conf 说明：用户参数主要设置用户的相关信息，主要是用户证书。如上的用户名为 admin，证书为：/etc/kubernetes/ssl/admin.pem，私钥为：/etc/kubernetes/ssl/admin-key.pem。注意客户端的证书首先要经过集群 CA 的签署，否则不会被集群认可。此处使用的是 ca 认证方式，也可以使用 token 认证，如 kubelet 的 TLS Boostrap 机制下的 bootstrapping 使用的就是 token 认证方式。 4、设置上下文参数 kubectl config set-context kubernetes –cluster=kubernetes –user=admin #可以指定路径 kubeconfig=/root/config.conf 说明：上下文参数将 集群参数和用户参数关联起来。如上面的上下文名称为 kubenetes，集群为 kubenetes，用户为 admin，表示使用 admin 的用户凭证来访问 kubenetes 集群的 default 命名空间，也可以增加 –namspace 来指定访问的命名空间。 5、设置默认上下文 kubectl config use-context kubernetes #可以指定路径 kubeconfig=/root/config.conf 说明：最后使用kubectl config use-context kubernetes 来使用名为 kubenetes 的环境项来作为配置。如果配置了多个环境项，可通过切换不同的环境项名字来访问到不同的集群环境。 完整的 k8s 的认证方式 https://zhuanlan.zhihu.com/p/97797321 ","date":"2022-03-19","objectID":"/kubernetes%E5%9F%BA%E7%A1%80/:6:1","tags":[],"title":"Kubernetes基础","uri":"/kubernetes%E5%9F%BA%E7%A1%80/"},{"categories":["native cloud"],"content":"七、 网络 ","date":"2022-03-19","objectID":"/kubernetes%E5%9F%BA%E7%A1%80/:7:0","tags":[],"title":"Kubernetes基础","uri":"/kubernetes%E5%9F%BA%E7%A1%80/"},{"categories":["native cloud"],"content":"八、 存储 ","date":"2022-03-19","objectID":"/kubernetes%E5%9F%BA%E7%A1%80/:8:0","tags":[],"title":"Kubernetes基础","uri":"/kubernetes%E5%9F%BA%E7%A1%80/"},{"categories":["native cloud"],"content":"8.2 ConfigMap (1) 是什么？ configMap 就是 k8s 中的配置，本质是键值对 (2) 为什么用 configMap ? 不是 yml 吗？有哪些地方需要用到配置？ (3) 方向（configMap 主要考虑创建和使用两部分） 创建 使用 配置文件（configMap、secret 都存储在 etcd 中了） configMap 可以用来保存单个属性，也可以保存配置文件 (4) configMap 作用 设置环境变量的值 设置命令行参数 在数据卷中创建 config 文件 (5) 与 secret 的区别： configMap 是不需要加密的配置，其他基本相同 (6) 其他资料 配置中心的概念，比如携程的开源分布式配置中心 Apollo ","date":"2022-03-19","objectID":"/kubernetes%E5%9F%BA%E7%A1%80/:8:1","tags":[],"title":"Kubernetes基础","uri":"/kubernetes%E5%9F%BA%E7%A1%80/"},{"categories":["native cloud"],"content":"九、 集群扩展 ","date":"2022-03-19","objectID":"/kubernetes%E5%9F%BA%E7%A1%80/:9:0","tags":[],"title":"Kubernetes基础","uri":"/kubernetes%E5%9F%BA%E7%A1%80/"},{"categories":["native cloud"],"content":"十、配置 ","date":"2022-03-19","objectID":"/kubernetes%E5%9F%BA%E7%A1%80/:10:0","tags":[],"title":"Kubernetes基础","uri":"/kubernetes%E5%9F%BA%E7%A1%80/"},{"categories":["native cloud"],"content":"9.1 apiVersion Deployment 可用 apps/v1 1.6版本之前 apiVsersion：extensions/v1beta1 1.6版本到1.9版本之间：apps/v1beta1 1.9版本之后:apps/v1 pods 可以直接是 v1 ","date":"2022-03-19","objectID":"/kubernetes%E5%9F%BA%E7%A1%80/:10:1","tags":[],"title":"Kubernetes基础","uri":"/kubernetes%E5%9F%BA%E7%A1%80/"},{"categories":["native cloud"],"content":"9.2 spec 对于 Deployment，spec 下的 selector 字段是 required 的 meta 理解为类型属性的描述 metav1.TypeMeta -\u003e kind/apiVersion spce：定义 API 对象类型私有属性。 -\u003e spec. (也是这个字段使得不同 API 对象得以区分) Status : 描述对象的状态 ","date":"2022-03-19","objectID":"/kubernetes%E5%9F%BA%E7%A1%80/:10:2","tags":[],"title":"Kubernetes基础","uri":"/kubernetes%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":" 警告 Sorry, this article has not been completely translated into French. Welcome to take the time to propose a translation by  making a PR to the theme!  LoveIt is a clean, elegant but advanced blog theme for Hugo developed by Dillon. It is based on the original LeaveIt Theme and KeepIt Theme. Hugo Theme LoveItHugo Theme LoveIt \" Hugo Theme LoveIt ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"À propos de LoveIt","uri":"/about/"},{"categories":null,"content":"Features Performance and SEO  Optimized for performance: 99/100 on mobile and 100/100 on desktop in Google PageSpeed Insights  Optimized SEO performance with a correct SEO SCHEMA based on JSON-LD  Google Analytics supported  Fathom Analytics supported  Search engine verification supported (Google, Bind, Yandex and Baidu)  CDN for third-party libraries supported  Automatically converted images with Lazy Load by lazysizes Appearance and Layout / Responsive layout / Light/Dark mode  Globally consistent design language  Pagination supported  Easy-to-use and self-expanding table of contents  Multilanguage supported and i18n ready  Beautiful CSS animation Social and Comment Systems  Gravatar supported by Gravatar  Local Avatar supported  Up to 64 social links supported  Up to 28 share sites supported  Disqus comment system supported by Disqus  Gitalk comment system supported by Gitalk  Valine comment system supported by Valine  Facebook comments system supported by Facebook  Telegram comments system supported by Comments  Commento comment system supported by Commento  Utterances comment system supported by Utterances Extended Features  Search supported by Lunr.js or algolia  Twemoji supported  Automatically highlighting code  Copy code to clipboard with one click  Images gallery supported by lightgallery.js  Extended Markdown syntax for Font Awesome icons  Extended Markdown syntax for ruby annotation  Extended Markdown syntax for fraction  Mathematical formula supported by $ \\KaTeX $  Diagrams shortcode supported by mermaid  Interactive data visualization shortcode supported by ECharts  Mapbox shortcode supported by Mapbox GL JS  Music player shortcode supported by APlayer and MetingJS  Bilibili player shortcode  Kinds of admonitions shortcode  Custom style shortcode  Custom script shortcode  Animated typing supported by TypeIt  Dynamic scroll supported by Smooth Scroll  Cookie consent banner supported by cookieconsent … ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"À propos de LoveIt","uri":"/about/"},{"categories":null,"content":"License LoveIt is licensed under the MIT license. Check the LICENSE file for details. Thanks to the authors of following resources included in the theme: normalize.css Font Awesome Simple Icons Animate.css Smooth Scroll autocomplete.js Lunr.js algoliasearch lazysizes object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"À propos de LoveIt","uri":"/about/"}]